---
interface Props {
  title: string;
  audioUrl: string;
  subtitleUrl?: string;
}

const { title, audioUrl, subtitleUrl } = Astro.props as Props;
---

<div
  class="episode-player"
  data-episode-player
  tabindex="0"
  aria-label={`${title} audio player`}
>
  <div class="episode-player__controls">
    <button
      class="episode-player__control episode-player__control--play"
      type="button"
      data-action="play"
      aria-label={`Play ${title}`}
      aria-describedby="episode-player-status"
    >
      <svg class="episode-player__control-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
        <path d="M8 5v14l11-7z" />
      </svg>
    </button>
    <button
      class="episode-player__control episode-player__control--pause"
      type="button"
      data-action="pause"
      aria-label={`Pause ${title}`}
      aria-describedby="episode-player-status"
      hidden
    >
      <svg class="episode-player__control-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
      </svg>
    </button>
  </div>

  <div
    class="episode-player__status"
    id="episode-player-status"
    aria-live="polite"
    aria-atomic="true"
  >
    {title}
  </div>

  <div class="episode-player__progress-wrap">
    <span id="episode-player-progress-label" class="episode-player__sr-only">
      Audio progress
    </span>
    <div
      class="episode-player__progress"
      role="slider"
      aria-labelledby="episode-player-progress-label"
      aria-valuemin="0"
      aria-valuemax="100"
      aria-valuenow="0"
      aria-valuetext="0:00 of 0:00"
      tabindex="0"
    >
      <div class="episode-player__progress-fill" aria-hidden="true"></div>
    </div>
  </div>

  <div class="episode-player__meta">
    <span
      class="episode-player__time"
      id="episode-player-time"
      aria-live="polite"
      aria-atomic="true"
    >
      0:00 / 0:00
    </span>
    <span
      class="episode-player__shortcut-hint episode-player__shortcut-hint--hidden"
      id="episode-player-hint"
      aria-live="polite"
    >
      Press ? for shortcuts (Space, ←/→, Home/End)
    </span>
  </div>

  <div
    class="episode-player__transport"
    role="group"
    aria-label="Audio player controls"
  >
    <button
      class="episode-player__transport-button"
      type="button"
      data-action="rewind"
      aria-label="Rewind 10 seconds"
      title="Rewind 10 seconds"
    >
      <svg class="episode-player__transport-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
        <path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z" />
      </svg>
    </button>
    <button
      class="episode-player__transport-button"
      type="button"
      data-action="forward"
      aria-label="Forward 10 seconds"
      title="Forward 10 seconds"
    >
      <svg class="episode-player__transport-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
        <path d="M12 5V1l5 5-5 5V7c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6h2c0 4.42-3.58 8-8 8s-8-3.58-8-8 3.58-8 8-8z" />
      </svg>
    </button>
  </div>

  <audio
    class="episode-player__audio"
    preload="metadata"
    aria-label={`Audio player for ${title}`}
    data-title={title}
    crossorigin="anonymous"
  >
    <source src={audioUrl} type="audio/mpeg" />
    {subtitleUrl && (
      <track
        kind="captions"
        src={subtitleUrl}
        srclang="en"
        label="English"
        default
      />
    )}
    Your browser does not support the audio element.
  </audio>
</div>

<script is:inline>
  (() => {
    const players = document.querySelectorAll(".episode-player");
    if (!players.length) return;

    const formatTime = (seconds) => {
      const safeSeconds = Number.isFinite(seconds) ? seconds : 0;
      const minutes = Math.floor(safeSeconds / 60);
      const remainingSeconds = Math.floor(safeSeconds % 60);
      return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
    };

    players.forEach((player) => {
      const audio = player.querySelector(".episode-player__audio");
      if (!(audio instanceof HTMLAudioElement)) return;

      const playButton = player.querySelector('[data-action="play"]');
      const pauseButton = player.querySelector('[data-action="pause"]');
      const rewindButton = player.querySelector('[data-action="rewind"]');
      const forwardButton = player.querySelector('[data-action="forward"]');
      const progress = player.querySelector(".episode-player__progress");
      const progressFill = player.querySelector(".episode-player__progress-fill");
      const timeDisplay = player.querySelector(".episode-player__time");
      const status = player.querySelector(".episode-player__status");
      const hint = player.querySelector(".episode-player__shortcut-hint");

      let isPlaying = false;
      const title = audio.dataset.title || "episode";

      const setStatus = (message) => {
        if (status) status.textContent = message;
      };

      const updateButtons = () => {
        if (!(playButton instanceof HTMLElement) || !(pauseButton instanceof HTMLElement)) return;
        playButton.hidden = isPlaying;
        pauseButton.hidden = !isPlaying;
      };

      const updateProgress = () => {
        if (!(progressFill instanceof HTMLElement) || !(progress instanceof HTMLElement) || !(timeDisplay instanceof HTMLElement)) {
          return;
        }

        const duration = Number.isFinite(audio.duration) ? audio.duration : 0;
        const currentTime = Number.isFinite(audio.currentTime) ? audio.currentTime : 0;
        const progressValue = duration ? (currentTime / duration) * 100 : 0;

        progressFill.style.width = `${progressValue}%`;
        progress.setAttribute("aria-valuenow", Math.round(progressValue).toString());

        const currentFormatted = formatTime(currentTime);
        const durationFormatted = duration ? formatTime(duration) : "0:00";
        timeDisplay.textContent = `${currentFormatted} / ${durationFormatted}`;
        progress.setAttribute(
          "aria-valuetext",
          `${currentFormatted} of ${durationFormatted}`,
        );
      };

      const seekToPosition = (clientX) => {
        if (!(progress instanceof HTMLElement) || !Number.isFinite(audio.duration)) return;
        const rect = progress.getBoundingClientRect();
        const percent = Math.min(1, Math.max(0, (clientX - rect.left) / rect.width));
        audio.currentTime = percent * audio.duration;
      };

      playButton?.addEventListener("click", () => {
        audio.play();
        isPlaying = true;
        setStatus(`Playing ${title}`);
        updateButtons();
      });

      pauseButton?.addEventListener("click", () => {
        audio.pause();
        isPlaying = false;
        setStatus(`Paused ${title}`);
        updateButtons();
      });

      rewindButton?.addEventListener("click", () => {
        audio.currentTime = Math.max(0, audio.currentTime - 10);
        updateProgress();
      });

      forwardButton?.addEventListener("click", () => {
        if (Number.isFinite(audio.duration)) {
          audio.currentTime = Math.min(audio.duration, audio.currentTime + 10);
          updateProgress();
        }
      });

      progress?.addEventListener("click", (event) => {
        if (event instanceof MouseEvent) {
          seekToPosition(event.clientX);
          updateProgress();
        }
      });

      progress?.addEventListener("keydown", (event) => {
        if (!Number.isFinite(audio.duration)) return;
        const step = 5;
        const largeStep = 15;

        if (["ArrowLeft", "ArrowRight", "Home", "End", "PageUp", "PageDown"].includes(event.key)) {
          event.preventDefault();
          switch (event.key) {
            case "ArrowLeft":
              audio.currentTime = Math.max(0, audio.currentTime - step);
              break;
            case "ArrowRight":
              audio.currentTime = Math.min(audio.duration, audio.currentTime + step);
              break;
            case "Home":
              audio.currentTime = 0;
              break;
            case "End":
              audio.currentTime = audio.duration;
              break;
            case "PageUp":
              audio.currentTime = Math.min(audio.duration, audio.currentTime + largeStep);
              break;
            case "PageDown":
              audio.currentTime = Math.max(0, audio.currentTime - largeStep);
              break;
          }
          updateProgress();
        }
      });

      player.addEventListener("keydown", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        if (target.classList.contains("episode-player__progress")) return;
        if (["BUTTON", "A", "INPUT", "TEXTAREA"].includes(target.tagName)) return;

        if (event.code === "Space") {
          event.preventDefault();
          if (isPlaying) {
            pauseButton?.click();
          } else {
            playButton?.click();
          }
        } else if (event.code === "ArrowLeft") {
          rewindButton?.click();
        } else if (event.code === "ArrowRight") {
          forwardButton?.click();
        } else if (event.key === "?") {
          event.preventDefault();
          if (hint instanceof HTMLElement) {
            hint.classList.toggle("episode-player__shortcut-hint--hidden");
          }
        }
      });

      audio.addEventListener("loadedmetadata", updateProgress);
      audio.addEventListener("timeupdate", updateProgress);
      audio.addEventListener("waiting", () => {
        setStatus(`Buffering ${title}...`);
      });
      audio.addEventListener("error", () => {
        setStatus(`Error loading ${title}`);
      });
      audio.addEventListener("playing", () => {
        isPlaying = true;
        updateButtons();
        setStatus(`Playing ${title}`);
      });
      audio.addEventListener("pause", () => {
        if (audio.ended) return;
        isPlaying = false;
        updateButtons();
        setStatus(`Paused ${title}`);
      });
      audio.addEventListener("ended", () => {
        isPlaying = false;
        updateButtons();
        if (progressFill instanceof HTMLElement) progressFill.style.width = "0%";
        updateProgress();
        setStatus(`Finished ${title}`);
      });

      setStatus(`Paused ${title}`);
      updateProgress();
      updateButtons();
    });
  })();
</script>

<style>
  .episode-player {
    display: grid;
    gap: 1rem;
    text-align: center;
    outline: none;
  }

  .episode-player:focus-visible {
    border-radius: 0.85rem;
    box-shadow: var(--focus-ring);
  }

  .episode-player__controls {
    display: flex;
    justify-content: center;
    gap: 0.75rem;
  }

  .episode-player__control {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 3.4rem;
    height: 3.4rem;
    border-radius: 999px;
    border: none;
    background: var(--color-primary);
    color: var(--color-background);
    box-shadow: var(--shadow-strong);
    cursor: pointer;
    transition: transform 0.15s ease, box-shadow 0.15s ease;
  }

  .episode-player__control:focus-visible {
    outline: none;
    box-shadow: var(--focus-ring);
  }

  .episode-player__control:hover {
    transform: translateY(-1px) scale(1.02);
  }

  .episode-player__control--pause {
    background: var(--color-secondary);
  }

  .episode-player__control-icon {
    width: 1.8rem;
    height: 1.8rem;
  }

  .episode-player__status {
    font-size: 1.05rem;
    font-weight: 600;
    color: var(--color-text);
  }

  .episode-player__progress-wrap {
    width: 100%;
  }

  .episode-player__progress {
    position: relative;
    width: 100%;
    height: 0.65rem;
    border-radius: 999px;
    background: color-mix(in srgb, var(--color-layer-2) 80%, var(--color-primary) 20%);
    border: 1px solid color-mix(in srgb, var(--color-primary) 20%, transparent);
    cursor: pointer;
  }

  .episode-player__progress:focus-visible {
    outline: none;
    box-shadow: var(--focus-ring);
  }

  .episode-player__progress-fill {
    position: absolute;
    inset: 0 auto 0 0;
    width: 0%;
    border-radius: inherit;
    background: var(--brand-gradient);
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.1);
    transition: width 0.15s ease-out;
  }

  .episode-player__meta {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.35rem;
    font-size: 0.9rem;
    color: var(--color-text-muted);
  }

  .episode-player__shortcut-hint {
    font-size: 0.8rem;
  }

  .episode-player__shortcut-hint--hidden {
    display: none;
  }

  .episode-player__transport {
    display: flex;
    justify-content: center;
    gap: 1rem;
  }

  .episode-player__transport-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.35rem;
    border-radius: 0.6rem;
    border: 1px solid color-mix(in srgb, var(--color-primary) 25%, transparent);
    background: transparent;
    color: var(--color-text-muted);
    cursor: pointer;
    transition: color 0.15s ease, border-color 0.15s ease, transform 0.15s ease;
  }

  .episode-player__transport-button:hover {
    color: var(--color-text);
    border-color: var(--color-primary);
    transform: translateY(-1px);
  }

  .episode-player__transport-button:focus-visible {
    outline: none;
    box-shadow: var(--focus-ring);
  }

  .episode-player__transport-icon {
    width: 1.4rem;
    height: 1.4rem;
  }

  .episode-player__audio {
    display: none;
  }

  .episode-player__sr-only {
    position: absolute !important;
    width: 1px !important;
    height: 1px !important;
    padding: 0 !important;
    margin: -1px !important;
    overflow: hidden !important;
    clip: rect(0 0 0 0) !important;
    white-space: nowrap !important;
    border: 0 !important;
  }
</style>
