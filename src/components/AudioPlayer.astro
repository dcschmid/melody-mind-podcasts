---
interface Props {
  title: string;
  audioUrl: string;
  subtitleUrl?: string;
}

const { title, audioUrl, subtitleUrl } = Astro.props as Props;
const playerId = subtitleUrl ?? audioUrl;
---

<div
  class="episode-player"
  data-episode-player
  data-player-id={playerId}
  tabindex="0"
  aria-label={`${title} audio player`}
>
  <div class="episode-player__controls">
    <button
      class="episode-player__control"
      type="button"
      data-action="toggle"
      aria-label={`Play ${title}`}
      aria-pressed="false"
      aria-describedby="episode-player-status"
    >
      <svg
        class="episode-player__control-icon episode-player__control-icon--play"
        viewBox="0 0 24 24"
        fill="currentColor"
        aria-hidden="true"
      >
        <path d="M8 5v14l11-7z" />
      </svg>
      <svg
        class="episode-player__control-icon episode-player__control-icon--pause"
        viewBox="0 0 24 24"
        fill="currentColor"
        aria-hidden="true"
        hidden
      >
        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
      </svg>
    </button>
  </div>

  <div
    class="episode-player__status"
    id="episode-player-status"
    aria-live="polite"
    aria-atomic="true"
  >
    {title}
  </div>

  <div class="episode-player__progress-wrap">
    <span id="episode-player-progress-label" class="episode-player__sr-only">
      Audio progress
    </span>
    <div
      class="episode-player__progress"
      role="slider"
      aria-labelledby="episode-player-progress-label"
      aria-valuemin="0"
      aria-valuemax="100"
      aria-valuenow="0"
      aria-valuetext="0:00 of 0:00"
      tabindex="0"
    >
      <div class="episode-player__progress-fill" aria-hidden="true"></div>
    </div>
  </div>

  <div class="episode-player__meta">
    <span
      class="episode-player__time"
      id="episode-player-time"
      aria-live="polite"
      aria-atomic="true"
    >
      0:00 / 0:00
    </span>
    <span
      class="episode-player__shortcut-hint episode-player__shortcut-hint--hidden"
      id="episode-player-hint"
      aria-live="polite"
    >
      Press ? for shortcuts (Space, ←/→, Home/End)
    </span>
  </div>

  <div
    class="episode-player__transport"
    role="group"
    aria-label="Audio player controls"
  >
    <button
      class="episode-player__transport-button"
      type="button"
      data-action="rewind"
      aria-label="Rewind 10 seconds"
      title="Rewind 10 seconds"
    >
      <svg class="episode-player__transport-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
        <path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z" />
      </svg>
    </button>
    <button
      class="episode-player__transport-button"
      type="button"
      data-action="forward"
      aria-label="Forward 10 seconds"
      title="Forward 10 seconds"
    >
      <svg class="episode-player__transport-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
        <path d="M12 5V1l5 5-5 5V7c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6h2c0 4.42-3.58 8-8 8s-8-3.58-8-8 3.58-8 8-8z" />
      </svg>
    </button>
  </div>

  <audio
    class="episode-player__audio"
    preload="metadata"
    aria-label={`Audio player for ${title}`}
    data-title={title}
    crossorigin="anonymous"
  >
    <source src={audioUrl} type="audio/mpeg" />
    {subtitleUrl && (
      <track
        kind="captions"
        src={subtitleUrl}
        srclang="en"
        label="English"
        default
      />
    )}
    Your browser does not support the audio element.
  </audio>
</div>

<script is:inline>
  (() => {
    const players = document.querySelectorAll(".episode-player");
    if (!players.length) return;

    const formatTime = (seconds) => {
      const safeSeconds = Number.isFinite(seconds) ? seconds : 0;
      const minutes = Math.floor(safeSeconds / 60);
      const remainingSeconds = Math.floor(safeSeconds % 60);
      return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
    };

    players.forEach((player) => {
      const audio = player.querySelector(".episode-player__audio");
      if (!(audio instanceof HTMLAudioElement)) return;

      const playerId = player.getAttribute("data-player-id") || "";
      const toggleButton = player.querySelector('[data-action="toggle"]');
      const rewindButton = player.querySelector('[data-action="rewind"]');
      const forwardButton = player.querySelector('[data-action="forward"]');
      const playIcon = toggleButton?.querySelector(".episode-player__control-icon--play");
      const pauseIcon = toggleButton?.querySelector(".episode-player__control-icon--pause");
      const progress = player.querySelector(".episode-player__progress");
      const progressFill = player.querySelector(".episode-player__progress-fill");
      const timeDisplay = player.querySelector(".episode-player__time");
      const status = player.querySelector(".episode-player__status");
      const hint = player.querySelector(".episode-player__shortcut-hint");

      let isPlaying = false;
      const title = audio.dataset.title || "episode";

      const dispatchTimeEvent = () => {
        if (!playerId) return;
        const duration = Number.isFinite(audio.duration) ? audio.duration : 0;
        const currentTime = Number.isFinite(audio.currentTime) ? audio.currentTime : 0;
        window.dispatchEvent(
          new CustomEvent("audio:time", {
            detail: {
              playerId,
              currentTime,
              duration,
              isPlaying,
            },
          }),
        );
      };

      const setStatus = (message) => {
        if (status) status.textContent = message;
      };

      const updateToggleButton = () => {
        if (!(toggleButton instanceof HTMLButtonElement)) return;
        toggleButton.dataset.state = isPlaying ? "playing" : "paused";
        toggleButton.setAttribute("aria-pressed", isPlaying ? "true" : "false");
        toggleButton.setAttribute("aria-label", `${isPlaying ? "Pause" : "Play"} ${title}`);
        if (playIcon instanceof SVGElement) {
          playIcon.style.display = isPlaying ? "none" : "block";
        }
        if (pauseIcon instanceof SVGElement) {
          pauseIcon.style.display = isPlaying ? "block" : "none";
        }
      };

      const updateProgress = () => {
        if (!(progressFill instanceof HTMLElement) || !(progress instanceof HTMLElement) || !(timeDisplay instanceof HTMLElement)) {
          return;
        }

        const duration = Number.isFinite(audio.duration) ? audio.duration : 0;
        const currentTime = Number.isFinite(audio.currentTime) ? audio.currentTime : 0;
        const progressValue = duration ? (currentTime / duration) * 100 : 0;

        progressFill.style.width = `${progressValue}%`;
        progress.setAttribute("aria-valuenow", Math.round(progressValue).toString());

        const currentFormatted = formatTime(currentTime);
        const durationFormatted = duration ? formatTime(duration) : "0:00";
        timeDisplay.textContent = `${currentFormatted} / ${durationFormatted}`;
        progress.setAttribute(
          "aria-valuetext",
          `${currentFormatted} of ${durationFormatted}`,
        );
      };

      const applySeek = (timeSeconds, autoplay) => {
        if (!Number.isFinite(timeSeconds)) return;
        const duration = Number.isFinite(audio.duration) ? audio.duration : null;
        const clampedTime =
          duration === null
            ? Math.max(0, timeSeconds)
            : Math.min(Math.max(0, timeSeconds), duration);
        audio.currentTime = clampedTime;
        if (autoplay) {
          const playPromise = audio.play();
          if (playPromise && typeof playPromise.catch === "function") {
            playPromise.catch(() => {});
          }
        }
        updateProgress();
        dispatchTimeEvent();
      };

      const seekToPosition = (clientX) => {
        if (!(progress instanceof HTMLElement) || !Number.isFinite(audio.duration)) return;
        const rect = progress.getBoundingClientRect();
        const percent = Math.min(1, Math.max(0, (clientX - rect.left) / rect.width));
        audio.currentTime = percent * audio.duration;
      };

      toggleButton?.addEventListener("click", () => {
        if (audio.paused || audio.ended) {
          audio.play();
        } else {
          audio.pause();
        }
      });

      rewindButton?.addEventListener("click", () => {
        audio.currentTime = Math.max(0, audio.currentTime - 10);
        updateProgress();
        dispatchTimeEvent();
      });

      forwardButton?.addEventListener("click", () => {
        if (Number.isFinite(audio.duration)) {
          audio.currentTime = Math.min(audio.duration, audio.currentTime + 10);
          updateProgress();
          dispatchTimeEvent();
        }
      });

      progress?.addEventListener("click", (event) => {
        if (event instanceof MouseEvent) {
          seekToPosition(event.clientX);
          updateProgress();
          dispatchTimeEvent();
        }
      });

      progress?.addEventListener("keydown", (event) => {
        if (!Number.isFinite(audio.duration)) return;
        const step = 5;
        const largeStep = 15;

        if (["ArrowLeft", "ArrowRight", "Home", "End", "PageUp", "PageDown"].includes(event.key)) {
          event.preventDefault();
          switch (event.key) {
            case "ArrowLeft":
              audio.currentTime = Math.max(0, audio.currentTime - step);
              break;
            case "ArrowRight":
              audio.currentTime = Math.min(audio.duration, audio.currentTime + step);
              break;
            case "Home":
              audio.currentTime = 0;
              break;
            case "End":
              audio.currentTime = audio.duration;
              break;
            case "PageUp":
              audio.currentTime = Math.min(audio.duration, audio.currentTime + largeStep);
              break;
            case "PageDown":
              audio.currentTime = Math.max(0, audio.currentTime - largeStep);
              break;
          }
          updateProgress();
          dispatchTimeEvent();
        }
      });

      player.addEventListener("keydown", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        if (target.classList.contains("episode-player__progress")) return;
        if (["BUTTON", "A", "INPUT", "TEXTAREA"].includes(target.tagName)) return;

        if (event.code === "Space") {
          event.preventDefault();
          toggleButton?.click();
        } else if (event.code === "ArrowLeft") {
          rewindButton?.click();
        } else if (event.code === "ArrowRight") {
          forwardButton?.click();
        } else if (event.key === "?") {
          event.preventDefault();
          if (hint instanceof HTMLElement) {
            hint.classList.toggle("episode-player__shortcut-hint--hidden");
          }
        }
      });

      window.addEventListener("transcript:seek", (event) => {
        if (!(event instanceof CustomEvent)) return;
        const detail = event.detail;
        if (!detail || detail.playerId !== playerId) return;
        const targetTime = Number(detail.time);
        applySeek(targetTime, Boolean(detail.autoplay));
      });

      audio.addEventListener("loadedmetadata", () => {
        updateProgress();
        dispatchTimeEvent();
      });
      audio.addEventListener("timeupdate", () => {
        updateProgress();
        dispatchTimeEvent();
      });
      audio.addEventListener("waiting", () => {
        setStatus(`Buffering ${title}...`);
      });
      audio.addEventListener("error", () => {
        setStatus(`Error loading ${title}`);
      });
      audio.addEventListener("playing", () => {
        isPlaying = true;
        updateToggleButton();
        setStatus(`Playing ${title}`);
        dispatchTimeEvent();
      });
      audio.addEventListener("pause", () => {
        if (audio.ended) return;
        isPlaying = false;
        updateToggleButton();
        setStatus(`Paused ${title}`);
        dispatchTimeEvent();
      });
      audio.addEventListener("ended", () => {
        isPlaying = false;
        updateToggleButton();
        if (progressFill instanceof HTMLElement) progressFill.style.width = "0%";
        updateProgress();
        setStatus(`Finished ${title}`);
        dispatchTimeEvent();
      });

      setStatus(`Paused ${title}`);
      updateProgress();
      updateToggleButton();
    });
  })();
</script>

<style>
  .episode-player {
    display: grid;
    gap: 1rem;
    text-align: center;
    outline: none;
  }

  .episode-player:focus-visible {
    border-radius: 0.85rem;
    box-shadow: var(--focus-ring);
  }

  .episode-player__controls {
    display: flex;
    justify-content: center;
    gap: 0.75rem;
  }

  .episode-player__control {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 3.4rem;
    height: 3.4rem;
    border-radius: 999px;
    border: 1px solid color-mix(in srgb, var(--color-primary) 30%, transparent);
    background: var(--color-primary);
    color: var(--color-background);
    box-shadow: var(--shadow-strong);
    cursor: pointer;
    transition: transform 0.15s ease, box-shadow 0.15s ease;
  }

  .episode-player__control[data-state="playing"] {
    background: var(--color-secondary);
  }

  .episode-player__control:focus-visible {
    outline: none;
    box-shadow: var(--focus-ring);
  }

  .episode-player__control:hover {
    transform: translateY(-1px) scale(1.02);
  }

  .episode-player__control-icon {
    display: block;
    width: 1.8rem;
    height: 1.8rem;
  }

  .episode-player__control-icon--pause {
    display: none;
  }

  .episode-player__control[data-state="playing"] .episode-player__control-icon--play {
    display: none;
  }

  .episode-player__control[data-state="playing"] .episode-player__control-icon--pause {
    display: block;
  }

  .episode-player__status {
    font-size: 1.05rem;
    font-weight: 600;
    color: var(--color-text);
  }

  .episode-player__progress-wrap {
    width: 100%;
  }

  .episode-player__progress {
    position: relative;
    width: 100%;
    height: 0.65rem;
    border-radius: 999px;
    background: var(--color-layer-3);
    border: 1px solid color-mix(in srgb, var(--color-primary) 28%, transparent);
    cursor: pointer;
  }

  .episode-player__progress:focus-visible {
    outline: none;
    box-shadow: var(--focus-ring);
  }

  .episode-player__progress-fill {
    position: absolute;
    inset: 0 auto 0 0;
    width: 0%;
    border-radius: inherit;
    background: var(--brand-gradient);
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.1);
    transition: width 0.15s ease-out;
  }

  .episode-player__meta {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.35rem;
    font-size: 0.9rem;
    color: var(--color-text-muted);
  }

  .episode-player__shortcut-hint {
    font-size: 0.8rem;
  }

  .episode-player__shortcut-hint--hidden {
    display: none;
  }

  .episode-player__transport {
    display: flex;
    justify-content: center;
    gap: 1rem;
  }

  .episode-player__transport-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.35rem;
    border-radius: 0.6rem;
    border: 1px solid color-mix(in srgb, var(--color-primary) 25%, transparent);
    background: transparent;
    color: var(--color-text-muted);
    cursor: pointer;
    transition: color 0.15s ease, border-color 0.15s ease, transform 0.15s ease;
  }

  .episode-player__transport-button:hover {
    color: var(--color-text);
    border-color: var(--color-primary);
    transform: translateY(-1px);
  }

  .episode-player__transport-button:focus-visible {
    outline: none;
    box-shadow: var(--focus-ring);
  }

  .episode-player__transport-icon {
    width: 1.4rem;
    height: 1.4rem;
  }

  .episode-player__audio {
    display: none;
  }

  .episode-player__sr-only {
    position: absolute !important;
    width: 1px !important;
    height: 1px !important;
    padding: 0 !important;
    margin: -1px !important;
    overflow: hidden !important;
    clip: rect(0 0 0 0) !important;
    white-space: nowrap !important;
    border: 0 !important;
  }
</style>
