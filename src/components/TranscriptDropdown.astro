---
interface Props {
  subtitleUrl?: string;
  podcastTitle: string;
}

const { subtitleUrl, podcastTitle } = Astro.props as Props;
---

{subtitleUrl && (
  <section
    class="transcript"
    aria-labelledby="transcript-title"
    data-subtitle-url={subtitleUrl}
    data-podcast-title={podcastTitle}
  >
    <details class="transcript__details">
      <summary class="transcript__summary">
        <span class="transcript__summary-title" id="transcript-title">ðŸ“„ Transcript</span>
        <span class="transcript__summary-hint">Show Transcript</span>
      </summary>
      <div class="transcript__body">
        <p class="transcript__status transcript__status--loading" hidden>
          Loading transcript...
        </p>
        <p class="transcript__status transcript__status--error" hidden>
          Error loading transcript
        </p>
        <div class="transcript__content" hidden></div>
      </div>
    </details>
  </section>
)}

<script is:inline>
  (() => {
    const roots = document.querySelectorAll(".transcript");
    roots.forEach((root) => {
      const subtitleUrl = root.getAttribute("data-subtitle-url");
      if (!subtitleUrl) return;

      const details = root.querySelector(".transcript__details");
      const hint = root.querySelector(".transcript__summary-hint");
      const loading = root.querySelector(".transcript__status--loading");
      const error = root.querySelector(".transcript__status--error");
      const content = root.querySelector(".transcript__content");

      if (!details || !content || !loading || !error || !hint) return;

      let loaded = false;
      let loadingInProgress = false;

      const updateHint = () => {
        hint.textContent = details.open ? "Hide Transcript" : "Show Transcript";
      };

      const parseTimeToSeconds = (timeStr) => {
        const clean = timeStr.split(/[ \t]/)[0];
        const parts = clean.split(":").map((part) => part.trim());
        if (parts.length === 3) {
          const [hours, minutes, seconds] = parts;
          return (
            parseInt(hours, 10) * 3600 +
            parseInt(minutes, 10) * 60 +
            parseFloat(seconds)
          );
        }
        if (parts.length === 2) {
          const [minutes, seconds] = parts;
          return parseInt(minutes, 10) * 60 + parseFloat(seconds);
        }
        return 0;
      };

      const formatTime = (totalSeconds) => {
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = Math.floor(totalSeconds % 60);
        return `${minutes}:${seconds.toString().padStart(2, "0")}`;
      };

      const parseVTT = (vttText) => {
        const lines = vttText.split("\n");
        const cues = [];
        let i = 0;

        while (i < lines.length && !lines[i].includes("-->")) {
          i++;
        }

        while (i < lines.length) {
          const line = lines[i].trim();
          if (line.includes("-->")) {
            const [startStr] = line.split("-->").map((part) => part.trim());
            i++;
            let cueText = "";

            while (
              i < lines.length &&
              lines[i].trim() !== "" &&
              !lines[i].includes("-->")
            ) {
              cueText += (cueText ? " " : "") + lines[i].trim();
              i++;
            }

            cueText = cueText.replace(/<[^>]*>/g, "").trim();
            if (cueText) {
              cues.push({ start: startStr, text: cueText });
            }
          } else {
            i++;
          }
        }

        return cues;
      };

      const renderCues = (cues) => {
        content.innerHTML = "";
        cues.forEach((cue) => {
          const cueRow = document.createElement("p");
          cueRow.className = "transcript__cue";

          const time = document.createElement("span");
          time.className = "transcript__time";
          time.textContent = formatTime(parseTimeToSeconds(cue.start));

          const text = document.createElement("span");
          text.className = "transcript__text";
          text.textContent = cue.text;

          cueRow.appendChild(time);
          cueRow.appendChild(text);
          content.appendChild(cueRow);
        });
      };

      const loadTranscript = async () => {
        if (loaded || loadingInProgress) return;
        loadingInProgress = true;
        loading.hidden = false;
        error.hidden = true;
        content.hidden = true;

        try {
          const response = await fetch(subtitleUrl);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const vttText = await response.text();
          const cues = parseVTT(vttText);

          if (cues.length === 0) {
            throw new Error("No cues found.");
          }

          renderCues(cues);
          content.hidden = false;
          loaded = true;
        } catch (err) {
          error.hidden = false;
        } finally {
          loading.hidden = true;
          loadingInProgress = false;
        }
      };

      details.addEventListener("toggle", () => {
        updateHint();
        if (details.open) {
          loadTranscript();
        }
      });

      updateHint();
    });
  })();
</script>

<style>
  .transcript {
    margin-top: 2rem;
    border: 1px solid color-mix(in srgb, var(--color-primary) 25%, transparent);
    border-radius: 1rem;
    background: var(--color-layer-4);
    box-shadow: var(--shadow-soft);
  }

  .transcript__summary {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem 1.25rem;
    cursor: pointer;
    list-style: none;
  }

  .transcript__summary::-webkit-details-marker {
    display: none;
  }

  .transcript__summary:focus-visible {
    outline: none;
    box-shadow: var(--focus-ring);
    border-radius: 0.5rem;
  }

  .transcript__summary-title {
    font-weight: 700;
    color: var(--color-text);
  }

  .transcript__summary-hint {
    font-size: 0.9rem;
    color: var(--color-text-muted);
  }

  .transcript__body {
    padding: 1rem 1.25rem 1.25rem;
    border-top: 1px solid color-mix(in srgb, var(--color-primary) 20%, transparent);
  }

  .transcript__status {
    margin: 0 0 0.75rem;
    color: var(--color-text-muted);
  }

  .transcript__status--error {
    color: var(--color-error-soft);
  }

  .transcript__content {
    display: grid;
    gap: 0.75rem;
    max-height: 24rem;
    overflow-y: auto;
    padding-right: 0.25rem;
  }

  :global(.transcript .transcript__cue) {
    margin: 0;
    padding: 0.85rem 1rem;
    border-radius: 0.85rem;
    background: var(--color-layer-1);
    border: 1px solid color-mix(in srgb, var(--color-primary) 18%, transparent);
    color: var(--color-text);
    line-height: 1.65;
    display: grid;
    grid-template-columns: minmax(3.5rem, auto) 1fr;
    gap: 0.75rem;
    align-items: start;
  }

  :global(.transcript .transcript__time) {
    display: inline-block;
    min-width: 3.5rem;
    font-weight: 600;
    color: var(--color-primary);
    font-variant-numeric: tabular-nums;
    text-align: right;
  }

  :global(.transcript .transcript__text) {
    color: var(--color-text);
  }
</style>
